<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Histogram of Oriented Gradients (HOG) | My New Hugo Site</title>
<meta name="keywords" content="#CV, #Machine_Learning, #extract_image">
<meta name="description" content="
There are many different methods in computer vision. When it comes to image classification, we can apply families of CNN models such as Inception Net, MobileNet, ResNet, DenseNet, AlexNet, U-Net, and so on. For object detection, models like YOLO, SSD, Faster R-CNN, Fast R-CNN, and Mask R-CNN are commonly used.
All the above algorithms belong to the deep learning category. However, before the deep learning boom, what algorithms were typically used in image processing? Today, we will explore a classic yet highly effective algorithm in image processing: HOG (Histogram of Oriented Gradients).
This algorithm generates features description for the purpose of object detection. From an image, two key matrices are extracted to store essential information: gradient magnitude and gradient orientation. By combining these two pieces of information into a histogram distribution—where the gradient magnitude is counted in bins according to gradient orientation—we obtain a HOG feature vector that represents the histogram. This is the basic concept, but in practice, the algorithm is more complex. The HOG vector is computed over local regions, similar to how CNNs operate, followed by local normalization to standardize measurements. Finally, the overall HOG vector is aggregated from all local vectors.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/hog/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6da9a63d25a9608bca2f7f907a030e887a7dd3c3f3918e4cc113129361414bda.css" integrity="sha256-bammPSWpYIvKL3&#43;QegMOiHp908PzkY5MwRMSk2FBS9o=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/hog/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>
<meta property="og:url" content="http://localhost:1313/posts/hog/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="Histogram of Oriented Gradients (HOG)">
  <meta property="og:description" content=" There are many different methods in computer vision. When it comes to image classification, we can apply families of CNN models such as Inception Net, MobileNet, ResNet, DenseNet, AlexNet, U-Net, and so on. For object detection, models like YOLO, SSD, Faster R-CNN, Fast R-CNN, and Mask R-CNN are commonly used. All the above algorithms belong to the deep learning category. However, before the deep learning boom, what algorithms were typically used in image processing? Today, we will explore a classic yet highly effective algorithm in image processing: HOG (Histogram of Oriented Gradients). This algorithm generates features description for the purpose of object detection. From an image, two key matrices are extracted to store essential information: gradient magnitude and gradient orientation. By combining these two pieces of information into a histogram distribution—where the gradient magnitude is counted in bins according to gradient orientation—we obtain a HOG feature vector that represents the histogram. This is the basic concept, but in practice, the algorithm is more complex. The HOG vector is computed over local regions, similar to how CNNs operate, followed by local normalization to standardize measurements. Finally, the overall HOG vector is aggregated from all local vectors.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-11T10:49:42+07:00">
    <meta property="article:modified_time" content="2025-03-11T10:49:42+07:00">
    <meta property="article:tag" content="#CV">
    <meta property="article:tag" content="#Machine_Learning">
    <meta property="article:tag" content="#Extract_image">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Histogram of Oriented Gradients (HOG)">
<meta name="twitter:description" content="
There are many different methods in computer vision. When it comes to image classification, we can apply families of CNN models such as Inception Net, MobileNet, ResNet, DenseNet, AlexNet, U-Net, and so on. For object detection, models like YOLO, SSD, Faster R-CNN, Fast R-CNN, and Mask R-CNN are commonly used.
All the above algorithms belong to the deep learning category. However, before the deep learning boom, what algorithms were typically used in image processing? Today, we will explore a classic yet highly effective algorithm in image processing: HOG (Histogram of Oriented Gradients).
This algorithm generates features description for the purpose of object detection. From an image, two key matrices are extracted to store essential information: gradient magnitude and gradient orientation. By combining these two pieces of information into a histogram distribution—where the gradient magnitude is counted in bins according to gradient orientation—we obtain a HOG feature vector that represents the histogram. This is the basic concept, but in practice, the algorithm is more complex. The HOG vector is computed over local regions, similar to how CNNs operate, followed by local normalization to standardize measurements. Finally, the overall HOG vector is aggregated from all local vectors.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Histogram of Oriented Gradients (HOG)",
      "item": "http://localhost:1313/posts/hog/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Histogram of Oriented Gradients (HOG)",
  "name": "Histogram of Oriented Gradients (HOG)",
  "description": " There are many different methods in computer vision. When it comes to image classification, we can apply families of CNN models such as Inception Net, MobileNet, ResNet, DenseNet, AlexNet, U-Net, and so on. For object detection, models like YOLO, SSD, Faster R-CNN, Fast R-CNN, and Mask R-CNN are commonly used. All the above algorithms belong to the deep learning category. However, before the deep learning boom, what algorithms were typically used in image processing? Today, we will explore a classic yet highly effective algorithm in image processing: HOG (Histogram of Oriented Gradients). This algorithm generates features description for the purpose of object detection. From an image, two key matrices are extracted to store essential information: gradient magnitude and gradient orientation. By combining these two pieces of information into a histogram distribution—where the gradient magnitude is counted in bins according to gradient orientation—we obtain a HOG feature vector that represents the histogram. This is the basic concept, but in practice, the algorithm is more complex. The HOG vector is computed over local regions, similar to how CNNs operate, followed by local normalization to standardize measurements. Finally, the overall HOG vector is aggregated from all local vectors.\n",
  "keywords": [
    "#CV", "#Machine_Learning", "#extract_image"
  ],
  "articleBody": " There are many different methods in computer vision. When it comes to image classification, we can apply families of CNN models such as Inception Net, MobileNet, ResNet, DenseNet, AlexNet, U-Net, and so on. For object detection, models like YOLO, SSD, Faster R-CNN, Fast R-CNN, and Mask R-CNN are commonly used. All the above algorithms belong to the deep learning category. However, before the deep learning boom, what algorithms were typically used in image processing? Today, we will explore a classic yet highly effective algorithm in image processing: HOG (Histogram of Oriented Gradients). This algorithm generates features description for the purpose of object detection. From an image, two key matrices are extracted to store essential information: gradient magnitude and gradient orientation. By combining these two pieces of information into a histogram distribution—where the gradient magnitude is counted in bins according to gradient orientation—we obtain a HOG feature vector that represents the histogram. This is the basic concept, but in practice, the algorithm is more complex. The HOG vector is computed over local regions, similar to how CNNs operate, followed by local normalization to standardize measurements. Finally, the overall HOG vector is aggregated from all local vectors.\nHOG Application There are some applications using HOG and which have high accuracy.\nHuman detection: This application first represents in Histogram of Orient Gradients for Human Detection). HOG can detect one or more people walking on a street in an image. Face detection: HOG is a good algorithm on this problem. It has the ability to represent the main contours of the face based on the direction and gradient magnitude through vectors for each cell as shown bellow Recognizing Various Objects: In addition, there are many cases of object recognition in static images, such as vehicles, traffic signals, animals, or even moving images extracted from videos.\nCreating Features for Image Classification Tasks: Many image classification tasks are built on small-sized datasets, where using deep learning networks may not always be effective and can lead to overfitting. The reason is that a small amount of data is often insufficient for training a model to accurately recognize object features. In such cases, using HOG (Histogram of Oriented Gradients) for feature extraction can yield better results. Specifically, I will also demonstrate an example at the end.\nTerminology Before diving into the HOG algorithm, I will first explain the terms used:\nFeature Descriptor: A feature descriptor is a representation of an image or an image patch that simplifies the image by extracting useful information and throwing away extraneous information.\nHistogram: A histogram is a graphical representation of the distribution of color intensities across different value ranges.\nGradient: The derivative or vector of color intensity changes that helps detect movement directions of objects in an image.\nLocal cell: A local cell is a small region in an image. In the HOG algorithm, an image is divided into multiple cells based on a square grid. Each cell is called a local cell.\nLocal portion: A local region is a section of the image where feature extraction is performed. In the algorithm, this local region is referred to as a “block.”\nLocal normalization: Normalization is performed within a local region. It is usually divided by either L2 norm or L1 norm. The purpose of normalization is to standardize color intensity values, making the distribution more consistent. This will be explained in more detail in the algorithm section.\nGradient direction: The gradient direction represents the angle between the gradient vector components $x$ and $y$, which helps determine the direction of intensity change or, in other words, the direction of shading in the image. Given that $G_x$​ and $G_y$​ are the gradient values along the $x$ and $y$ axes of the image, the gradient direction is calculated as:\n$$\\theta = \\arctan\\left(\\frac{G_y}{G_x}\\right)$$\nGradient magnitude: The magnitude of the gradient represents the length of the vector combining the gradients along the $x$ and $y$ directions. The histogram representation of this vector is used to describe the HOG features. The gradient magnitude is computed as:\n$$∣G∣=\\sqrt{G_x^2+G_y^2}$$​\nDefinition The key point in the working principle of HOG is that the local shape of an object can be described using two matrices: the gradient magnitude matrix and the gradient direction matrix. First, the image is divided into a grid of square cells, where many adjacent or overlapping local regions are identified. These regions are similar to the local image regions used in convolutional operations in CNNs. The main purpose of HOG feature extraction is to capture the local shape and edge information of an image. It works by computing the gradients (i.e., the changes in intensity) and then building histograms of these gradients over small, localized regions. This process allows the algorithm to effectively describe the appearance and structure of objects in an image, such as the contours and silhouettes of people.\nA local region consists of multiple local cells (in HOG, there are 4 cells) with a size of 8×8 pixels Then, a histogram of gradient magnitudes is computed for each local cell. The HOG descriptor is formed by concatenating the four histogram vectors corresponding to each cell into a single combined vector. To improve accuracy, each value in the histogram vector of a local region is normalized using either L2-norm or L1-norm. This normalization aims to enhance invariance to lighting and shading changes. The HOG descriptor has several key advantages over other feature descriptors:\nSince it operates on local cells, it is invariant to geometric transformations and brightness changes. Furthermore, as Dalal and Triggs discovered, applying local region normalization allows the descriptor to ignore minor body movements in pedestrian detection, as long as the person maintains an upright posture. This makes HOG particularly well-suited for human detection in images. How HOG Works (Step-by-step) Preprocessing In every image processing algorithm, the first step is preprocessing image. As mentioned earlier HOG feature descriptor used for pedestrian detection is calculated on a $64×128$ patch of an image. Of course, an image may be of any size. Typically, patches at multiple scales are analyzed at many image locations. The only constraint is that the patches being analyzed have a fixed aspect ratio. In our case, the patches need to have an aspect ratio of $1:2$. For example, they can be $100×200$, $128×256$, or $1000×2000$ but not $101×205$.\nWe need to adjust the image to grayscale\nimport numpy as np import cv2 import matplotlib.pyplot as plt #Read the image img = cv2.imread(\"./img/bolt.jpg\") # Load BGR format if img is None: print(\"Image not loaded. Check the file path and file integrity.\") else: # Convert BGR to RGB for proper color display in matplotlib img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #Convert to grayscale gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) print(img_rgb.shape) print(gray.shape) #Show the images plt.figure(figsize=(8,6)) plt.subplot(1,2,1) plt.imshow(img_rgb) plt.title(\"Original\") plt.subplot(1,2,2) plt.imshow(gray) plt.title(\"Gray Image\") plt.show() Compute the gradient To calculate a HOG descriptor, we need to first calculate the horizontal and vertical gradients, the common way to compute is using the Sobel operator\nHorizontal gradient $$G_x = \\begin{pmatrix} -1 \u0026 0 \u0026 2 \\ -2 \u0026 0 \u0026 2 \\ -1 \u0026 0 \u0026 1 \\end{pmatrix}*\\textbf{I} $$ Vertical gradient $$G_y = \\begin{bmatrix} -1 \u0026 -2 \u0026 -1 \\ 0 \u0026 0 \u0026 0 \\ 1 \u0026 2 \u0026 1 \\end{bmatrix} * \\mathbf{I} $$ Where $*$ be a convolution between a filter and an image Gradient magnitude $$ G=\\sqrt{G_x^2+G_y^2}$$ Gradient direction $$\\theta=\\arctan\\Bigl(\\frac{G_y}{G_x}\\Bigl)$$ #Calculate gradient gx,gy gx = cv2.Sobel(gray, cv2.CV_32F, dx = 0, dy = 1, ksize=3) gy = cv2.Sobel(gray, cv2.CV_32F, dx = 1, dy = 0, ksize=3) print('gray shape: {}'.format(gray.shape)) print('gx shape: {}'.format(gx.shape)) print('gy shape: {}'.format(gy.shape)) # Compute magnitude and direction gradient g, theta = cv2.cartToPolar(gx, gy, angleInDegrees=True) print('gradient format: {}'.format(g.shape)) print('theta format: {}'.format(theta.shape)) The output\ngray shape: (480, 640) gx shape: (480, 640) gy shape: (480, 640) gradient format: (480, 640) theta format: (480, 640) Visualize the plot\nplt.figure(figsize=(20, 10)) plt.subplot(1, 4, 1) plt.title('gradient of x') plt.imshow(gx) plt.subplot(1, 4, 2) plt.title('gradient of y') plt.imshow(gy) plt.subplot(1, 4, 3) plt.title('Magnitute of gradient') plt.imshow(g) plt.subplot(1, 4, 4) plt.title('Direction of gradient') plt.imshow(theta) plt.show() Calculate Histogram of Gradients in 8 x 8 cells In this step, the image is divided into $8\\times8$ cells and a histogram of gradients is calculated for each $8\\times8$. One of the important reasons to use a feature description to describe a patch of an image is that it provided a compact representation. An $8\\times8$ patch contain $8\\times8\\times3=192$ pixels. The gradient of this patch contains $2$ values (magnitude and direction) per pixel which adds up to $8\\times8\\times2 = 128$ numbers include $64$ values of gradient magnitude and $64$ values of gradient direction. By the end of this section we will see how these $128$ numbers are represented using a 9-bin histogram which can be stored as an array of $9$ numbers. Not only is the representation more compact, calculating a histogram over a patch makes this representation more robust to noise. Individual gradients may have noise, but a histogram over $8\\times8$ patch makes the representation much less sensitive to noise.\nBut why $8\\times8$ patch ? Why not $32\\times32$ ? It is a design choice informed by the scale of features we are looking for. HOG was used for pedestrian detection initially. $8\\times8$ cells in a photo of a pedestrian scaled to $64\\times128$ are big enough to capture interesting features ( e.g. the face, the top of the head etc.). On the right, we see the raw numbers representing the gradients in the 8×8 cells with one minor difference — the angles are between $0$ and $180$ degrees instead of $0$ to $360$ degrees. These are called “unsigned” gradients because a gradient and it’s negative are represented by the same numbers. In other words, a gradient arrow and the one $180$ degrees opposite to it are considered the same. But, why not use the $0$ – $360$ degrees ?\nEmpirically it has been shown that unsigned gradients work better than signed gradients for pedestrian detection. Some implementations of HOG will allow you to specify if you want to use signed gradients.\nThe next step is to create a histogram of gradients in these $8\\times8$ cells. The histogram contains 9 bins corresponding to angles $0, 20, 40 … 160$. The following figure illustrates the process. We are looking at magnitude and direction of the gradient of the same $8\\times8$ patch as in the previous figure. A bin is selected based on the direction, and the vote (the value that goes into the bin) is selected based on the magnitude. Let’s first focus on the pixel encircled in blue. It has an angle (direction) of $80$ degrees and magnitude of $2$. So it adds $2$ to the $5^{th}$ bin. The gradient at the pixel encircled using red has an angle of $10$ degrees and magnitude of $4$. Since $10$ degrees is half way between $0$ and $20$, the vote by the pixel splits evenly into the two bins.\nThe approach when gradient direction doesn’t fall in any bin(like an example 10 degrees), we will use linear interpolation to divided the gradients to 2 continuous bins which gradient direction falls. Obviously, the gradient direction equal $x$ map to the gradient magnitude $y$, where $x \\in [x_0,x_1]$. It’s will fall to a point between $(l-1)$ bin and $l$ bin. So that we write $$ x_{l-1}=\\frac{x_1-x}{x_1-x_0}*y, x_{l}=\\frac{x-x_0}{x_1-x_0}*y $$\nTake a sum of each gradient magnitude belong in one bins from vector bins and we collect Histogram of Gradient\n16×16 Block Normalization In the previous step, we created a histogram based on the gradient of the image. Gradients of an image are sensitive to overall lighting. If you make the image darker by dividing all pixel values by 2, the gradient magnitude will change by half, and therefore the histogram values will change by half.\nIdeally, we want our descriptor to be independent of lighting variations. In other words, we would like to “normalize” the histogram so they are not affected by lighting variations.\nLet’s say we have an RGB color vector $[128, 64, 32]$. This length of this vector is $\\sqrt{128^2+64^2+32^2}\\approx 146.64$. This is call L2 norm. Dividing each element of this vector give us a normalized vector $[0.87,0.43,0.22]$\nNow consider another vector in which the elements are twice the value of the first vector $2 \\times [ 128, 64, 32 ] = [ 256, 128, 64 ]$. You can work it out yourself to see that normalizing $[ 256, 128, 64 ]$ will result in $[0.87, 0.43, 0.22]$, which is the same as the normalized version of the original RGB vector. You can see that normalizing a vector removes the scale.\nThe normalization will be processed in a block size $2\\times 2$ cell (each cell size $8\\times8$ pixel). So we will have 4 vector histogram size $1\\times9$, concatenate vectors and we will have one vector histogram size $1\\times36$ and then normalized in this vector. Sliding the window will process the same as convolution in CNN with step_size = 8 pixels.\nCompute HOG features vector After normalizing the histogram vectors, we then concatenate these $1×36$ vectors into a single large vector. This becomes the HOG vector representing the entire image.\nFor example, suppose our image is divided into a grid of squares of size $16×8$ (each cell is $8×8$). The HOG computation moves $7$ steps horizontally and $15$ steps vertically. Thus, there are a total of $7×15 = 105$ patches, each corresponding to one $36$-dimensional histogram vector. Consequently, the final HOG vector will have $105×36 = 3780$ dimensions. This is a relatively large vector, which allows it to capture the image’s features quite effectively.\nVisualizing Histogram of Oriented Gradients The HOG descriptor of an image patch is usually visualized by plotting the 9×1 normalized histograms in the 8×8 cells. See image on the side. You will notice that dominant direction of the histogram captures the shape of the person, especially around the torso and legs.\nPractice We will use opencv to calculate the HOG features\nprint(\"Original {}\".format(img.shape)) cell_size = (8,8) # h x w pixels block_size = (2,2) # h x w cells nbins = 9 # number of bins in Histogram # winSize = the size of the image region (or window) that will be used by the HOG (Histogram of Oriented Gradients) descriptor winSize = (img.shape[1]// cell_size[1] * cell_size[1], img.shape[0] // cell_size[0] * cell_size[0]) # blockSize = the size compute in pixels blockSize = (block_size[1] * cell_size[1], block_size[0] * cell_size[0]) # blockStride = how far (in pixels) the detection window moves from one block to the next. blockStride = cell_size print(\"winSize\",winSize) print(\"blockSize\",block_size) print(\"blockStride\",blockStride) hog = cv2.HOGDescriptor(_winSize=winSize,_blockSize=blockSize,_blockStride=blockStride,_cellSize=cell_size,_nbins=9) # size of cell grid (from pixel -\u003e cell) n_cell = (winSize[0]//cell_size[0],winSize[1]//cell_size[1]) print(\"n_cell\",n_cell) hog_feature = hog.compute(img).reshape(n_cell[0] - block_size[0] + 1,n_cell[1] - block_size[1] + 1 ,block_size[0],block_size[1],nbins).transpose(1, 0, 2 , 3 , 4) print(\"hog feature\", hog_feature.shape) and the results\nOriginal (395, 634, 3) winSize (632, 392) blockSize (2, 2) blockStride (8, 8) n_cell (79, 49) hog feature (48, 78, 2, 2, 9) Note: Don’t like the order of the .shape, opencv use the order width x height (instead height x width).\nWe can visualize HOG distribution\nfrom skimage import exposure from skimage import feature import cv2 import matplotlib.pyplot as plt (H, hogImage) = feature.hog(gray, orientations=9, pixels_per_cell=(8, 8), cells_per_block=(2, 2), transform_sqrt=True, block_norm=\"L2\", visualize=True) hogImage = exposure.rescale_intensity(hogImage, out_range=(0, 255)) hogImage = hogImage.astype(\"uint8\") plt.imshow(hogImage) Application in HOG Human Detection To detect human in image or also video, we can use a pre-trained SVM (Support Vector Machine) model that makes predictions based on features extracted by the HOG (Histogram of Oriented Gradients) algorithm.\nImport lib from skimage.feature import hog from skimage.transform import pyramid_gaussian from skimage.io import imread import joblib from sklearn.preprocessing import LabelEncoder from sklearn.svm import LinearSVC from sklearn.metrics import classification_report, accuracy_score from sklearn.model_selection import train_test_split from skimage import color from imutils.object_detection import non_max_suppression import imutils import numpy as np import cv2 import argparse import cv2 import os import glob from PIL import Image # This will be used to read/modify images (can be done via OpenCV too) from numpy import * Define path to image base_path_test = \"../data/human-and-non-human/test_set/test_set\" # path for test base_path_train = \"../data/dataset\" # path for train # join the path pos_im_path = os.path.join(base_path_train, \"positive\") neg_im_path = os.path.join(base_path_train, \"negative\") #define negative image for SVM training pos_im_path_test = os.path.join(base_path_test, \"humans\") # for test data neg_im_path_test = os.path.join(base_path_test, \"non-humans\") # Check if there not exist path if not os.path.exists(pos_im_path): print(f\"Error: Path does not exist - {os.path.abspath(pos_im_path)}\") if not os.path.exists(neg_im_path): print(f\"Error: Path does not exist - {os.path.abspath(neg_im_path)}\") if not os.path.exists(pos_im_path_test): print(f\"Error: Path does not exist - {os.path.abspath(pos_im_path_test)}\") if not os.path.exists(neg_im_path_test): print(f\"Error: Path does not exist - {os.path.abspath(neg_im_path_test)}\") # Take the image in that path pos_im_listing = os.listdir(pos_im_path) neg_im_listing = os.listdir(neg_im_path) pos_im_listing_test = os.listdir(pos_im_path_test) neg_im_listing_test = os.listdir(neg_im_path_test) num_pos_samples = size(pos_im_listing) # simply states the total no. of images num_neg_samples = size(neg_im_listing) num_pos_test = size(pos_im_listing_test) num_neg_test = size(neg_im_listing_test) print(num_pos_samples) # prints the number value of the no.of samples in positive dataset print(num_neg_samples) print(num_pos_test) print(num_neg_test) data = [] labels = [] Compute the HOG features and label them # Putting label into positive image winSize = (64, 128) blockSize = (16, 16) blockStride = (8, 8) cellSize = (8, 8) nbins = 9 hog = cv2.HOGDescriptor(winSize, blockSize, blockStride, cellSize, nbins) for file in pos_im_listing: img_path = os.path.join(pos_im_path, file) try: img = Image.open(img_path).convert(\"RGB\") # Open the file # Convert into NumPy array img = np.array(img) # Convert RGB to BGR (for OpenCV compatibility) img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR) # Resize to standard HOG size (64x128) to ensure consistency img = cv2.resize(img, (64, 128)) #Convert to grayscale gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) fd = hog.compute(gray).flatten() # Must change into 1D array (because fd return a multi-dimensional vector) if fd.shape[0] != 3780: # Expected size for 64x128 image print(f\"Skipping {file} due to incorrect HOG feature shape: {fd.shape}\") continue # Skip this sample data.append(fd) labels.append(1) print(f\"Processed training data (positive): {file}\") except Exception as e: print(f\"Skipping {file} (Error: {e})\") # Putting label into negative image for file in neg_im_listing: img_path = os.path.join(neg_im_path, file) try: img = Image.open(img_path).convert(\"RGB\") # Open the file # Convert into NumPy array img = np.array(img) # Convert RGB to BGR (for OpenCV compatibility) img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR) # Resize to standard HOG size (64x128) to ensure consistency img = cv2.resize(img, (64, 128)) #Convert to grayscale gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) fd = hog.compute(gray).flatten() # Must change into 1D array (because fd return a multi-dimensional vector) if fd.shape[0] != 3780: # Expected size for 64x128 image print(f\"Skipping {file} due to incorrect HOG feature shape: {fd.shape}\") continue # Skip this sample data.append(fd) labels.append(0) print(f\"Processed training data (negative): {file}\") except Exception as e: print(f\"Skipping {file} (Error: {e})\") ## Testing label data_test = [] label_test = [] for file in pos_im_listing_test: img_path = os.path.join(pos_im_path_test, file) try: img = Image.open(img_path).convert(\"RGB\") # Open the file # Convert into NumPy array img = np.array(img) # Convert RGB to BGR (for OpenCV compatibility) img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR) # Resize to standard HOG size (64x128) to ensure consistency img = cv2.resize(img, (64, 128)) #Convert to grayscale gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Create a base features (if don't add any parameter, opencv will understand to take a base parameter) fd = hog.compute(gray).flatten() # Must change into 1D array (because fd return a multi-dimensional vector) if fd.shape[0] != 3780: # Expected size for 64x128 image print(f\"Skipping {file} due to incorrect HOG feature shape: {fd.shape}\") continue # Skip this sample data_test.append(fd) label_test.append(1) print(f\"Processed test data (positive): {file}\") except Exception as e: print(f\"Skipping {file} (Error: {e})\") # Putting label into negative image for file in neg_im_listing_test: img_path = os.path.join(neg_im_path_test, file) try: img = Image.open(img_path).convert(\"RGB\") # Open the file # Convert into NumPy array img = np.array(img) # Convert RGB to BGR (for OpenCV compatibility) img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR) # Resize to standard HOG size (64x128) to ensure consistency img = cv2.resize(img, (64, 128)) #Convert to grayscale gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) fd = hog.compute(gray).flatten() # Must change into 1D array (because fd return a multi-dimensional vector) if fd.shape[0] != 3780: # Expected size for 64x128 image print(f\"Skipping {file} due to incorrect HOG feature shape: {fd.shape}\") continue # Skip this sample data_test.append(fd) label_test.append(0) print(f\"Processed test data (negative): {file}\") except Exception as e: print(f\"Skipping {file} (Error: {e})\") Model testing print(\" Constructing training/testing split...\") data = np.array(data, dtype=np.float32) labels = np.array(labels, dtype=np.int32) data_test = np.array(data_test, dtype=np.float32) label_test = np.array(label_test, dtype=np.int32) print(data_test.shape) print(label_test.shape) (trainData, testData, trainLabels, testLabels) = (data, data_test, labels, label_test) # Train the linear SVM print(\" Training Linear SVM classifier...\") model = LinearSVC() model.fit(trainData, trainLabels) # Evaluate the classifier print(\" Evaluating classifier on test data ...\") pred = model.predict(testData) # Calculate accuracy accuracy = accuracy_score(testLabels, pred) print(f\"Accuracy: {accuracy}\") print(\"Report\\n\",classification_report(testLabels, pred)) # Save the model joblib.dump(model, 'SVM_HOG.pkl') print(\"SVM Model save Successfully!\") Constructing training/testing split... (1554, 3780) (1554,) Training Linear SVM classifier... Evaluating classifier on test data ... Accuracy: 0.8294723294723295 Report precision recall f1-score support 0 0.84 0.98 0.91 1309 1 0.00 0.00 0.00 245 accuracy 0.83 1554 macro avg 0.42 0.49 0.45 1554 weighted avg 0.71 0.83 0.76 1554 SVM Model save Successfully! Load model # Load the model by joblib model = joblib.load(\"SVM_HOG.pkl\") print(\"SVM Model load Successfully!\") Sliding window # Sliding window technique def sliding_window(image, stepSize, windowSize): for y in range(0, image.shape[0] - windowSize[1], stepSize): for x in range(0, image.shape[1] - windowSize[0], stepSize): yield (x, y, image[y:y + windowSize[1], x:x + windowSize[0]]) Detect people on image down_scale=1.25 window_size=(64,128) output_folder = 'results/' # Detect for file in pos_im_listing_test: scale = 0 img_path = os.path.join(pos_im_path_test, file) try: img = Image.open(img_path).convert(\"RGB\") # Open the file img = np.array(img) img = cv2.resize(img, (300,200)) # Debug: Check the shape of the image if img.shape[2] != 3: print(\"Skip\") continue detections = [] # Using pyramid to detect the larger or smaller object (scaled the image purpose sliding window will detect different object with original cell) for resized in pyramid_gaussian(img, downscale=down_scale, channel_axis = -1): # pyramid_gaussian convert the image into [0, 1] # So we need to convert back to unit8 resized = (resized * 255).astype(np.uint8) # Convert float64 to uint8, go back [0, 255] for (x , y , window) in sliding_window(resized, stepSize = 8, windowSize = window_size): # You can adjust the stepsize # validation the window size if (window.shape[1] != window_size[0] or window.shape[0] != window_size[1]): continue # change the window to gray, easily compute HOG window = cv2.cvtColor(window, cv2.COLOR_RGB2GRAY) #Extract HOG features fds = hog.compute(window) fds = fds.reshape(1 , -1) # Make become 2d #prediction SVM pred = model.predict(fds) # print(pred) if pred == 1: if (model.decision_function(fds) \u003e 0.5): # add threshold back_to_original = down_scale ** scale # When we use pyramid to shrink the image, we will give the detection window back to original size detections.append((x*back_to_original , y*back_to_original , int(window_size[0]*back_to_original), int(window_size[1]*back_to_original),model.decision_function(fds))) scale += 1 # increase the scale clone = img.copy() rects = np.array([[x,y,x + w , y + h] for (x,y,w,h,_) in detections]) sc = [score[0] for (_,_,_,_,score) in detections] sc = np.array(sc) # Apply Non-Maximum Suppression (NMS) if detections exist final_detections = non_max_suppression(rects, probs=sc, overlapThresh=0.35) #Draw bouding boxes for (x , y , w , h) in final_detections: cv2.rectangle(img, (x , y), (x + w, y + h), (0, 255, 0), 2) # Convert BGR to RGB for display in matplotlib img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # write down the result output_path = os.path.join(output_folder, file) cv2.imwrite(output_path, img_rgb) print(f\"Processed {file} successful\" ) except Exception as e: print(f\"Skipping {file} (Error: {e})\") Before using NMS\nAfter using NMS\nDetect people on video from IPython.display import display, clear_output import yt_dlp import PIL.Image # Load YouTube video using pafy url = 'https://youtu.be/NyLF8nHIquM' # Get the best video stream ydl_opts = {} with yt_dlp.YoutubeDL(ydl_opts) as ydl: info_dict = ydl.extract_info(url, download=False) video_url = info_dict['url'] cap = cv2.VideoCapture(video_url) # Set Optimized Performance cv2.setUseOptimized(True) cv2.setNumThreads(4) # Adjust based on CPU # Process every nth frame (skip frames) frame_skip = 2 frame_count = 0 # Read and process frames while True: ret, frame = cap.read() if not ret: break if frame_count % frame_skip != 0: frame_count += 1 continue frame_count += 1 # Increment counter img = cv2.resize(frame, (512,512)) detections = [] scale = 0 # Using pyramid to detect the larger or smaller object (scaled the image purpose sliding window will detect different object with original cell) for resized in pyramid_gaussian(img, downscale=down_scale, channel_axis = -1): # pyramid_gaussian convert the image into [0, 1] # So we need to convert back to unit8 resized = (resized * 255).astype(np.uint8) # Convert float64 to uint8, go back [0, 255] for (x , y , window) in sliding_window(resized, stepSize = 8, windowSize = window_size): # You can adjust the stepsize # validation the window size if (window.shape[1] != window_size[0] or window.shape[0] != window_size[1]): continue # change the window to gray, easily compute HOG window = cv2.cvtColor(window, cv2.COLOR_RGB2GRAY) #Extract HOG features fds = hog.compute(window) fds = fds.reshape(1 , -1) # Make become 2d #prediction SVM pred = model.predict(fds) # print(pred) if pred == 1: if (model.decision_function(fds) \u003e 0.5): # add threshold back_to_original = down_scale ** scale # When we use pyramid to shrink the image, we will give the detection window back to original size detections.append((x*back_to_original , y*back_to_original , int(window_size[0]*back_to_original), int(window_size[1]*back_to_original),model.decision_function(fds))) scale += 1 # increase the scale clone = img.copy() rects = np.array([[x,y,x + w , y + h] for (x,y,w,h,_) in detections]) sc = [score[0] for (_,_,_,_,score) in detections] sc = np.array(sc) # Apply Non-Maximum Suppression (NMS) if detections exist final_detections = non_max_suppression(rects, probs=sc, overlapThresh=0.35) #Draw bouding boxes for (x , y , w , h) in final_detections: cv2.rectangle(img, (x , y), (x + w, y + h), (0, 255, 0), 2) cv2.putText(img, 'Person: {:.2f}'.format(np.max(sc)), (x - 2, y - 2), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1) # Convert BGR to RGB for display in matplotlib img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) img_pil = PIL.Image.fromarray(img_rgb) # Clear previous frame and display new frame clear_output(wait=True) display(img_pil) # Add a small delay and allow stopping if cv2.waitKey(1) == 27: # Press ESC to exit break cap.release() cv2.destroyAllWindows() Summary In image processing, the Histogram of Oriented Gradients (HOG) algorithm is one of the powerful feature descriptors that encodes an image into a feature vector with a sufficiently large number of dimensions to effectively classify images. The algorithm works based on representing a histogram vector of gradient magnitudes according to bins of gradient directions applied to local image regions. Normalization methods are applied to make the aggregated histogram vector invariant to changes in image intensity, ensuring consistency for images with the same content but different brightness levels.\nIn object detection, the HOG algorithm proves to be highly effective, particularly in detecting people at various scales. Additionally, in some image classification cases where the dataset is small, large neural networks such as CNNs may not perform accurately due to the training set not covering all possible variations. In such situations, applying classical feature extraction methods like HOG can yield surprisingly good results while requiring fewer computational resources and lower costs.\nThis demonstrates that although HOG is an older method, it remains highly effective in many applications. Depending on the specific scenario, we may choose to use the HOG algorithm instead of necessarily applying a deep learning model with millions of parameters to achieve high accuracy.\nReference https://phamdinhkhanh.github.io/2019/11/22/HOG.html Object Detection for Dummies Part 1: Gradient Vector, HOG, and SS | Lil’Log Histogram of Oriented Gradients explained using OpenCV https://github.com/nguyentuss/CV (full code and data put in here) ",
  "wordCount" : "4506",
  "inLanguage": "en",
  "datePublished": "2025-03-11T10:49:42+07:00",
  "dateModified": "2025-03-11T10:49:42+07:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/hog/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Histogram of Oriented Gradients (HOG)
    </h1>
    <div class="post-meta"><span title='2025-03-11 10:49:42 +0700 +07'>March 11, 2025</span>&nbsp;·&nbsp;22 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#hog-application" aria-label="HOG Application">HOG Application</a></li>
                <li>
                    <a href="#terminology" aria-label="Terminology">Terminology</a></li>
                <li>
                    <a href="#definition" aria-label="Definition">Definition</a></li>
                <li>
                    <a href="#how-hog-works-step-by-step" aria-label="How HOG Works (Step-by-step)">How HOG Works (Step-by-step)</a><ul>
                        
                <li>
                    <a href="#preprocessing" aria-label="Preprocessing">Preprocessing</a></li>
                <li>
                    <a href="#compute-the-gradient" aria-label="Compute the gradient">Compute the gradient</a></li>
                <li>
                    <a href="#calculate-histogram-of-gradients-in-8-x-8-cells" aria-label="Calculate Histogram of Gradients in 8 x 8 cells">Calculate Histogram of Gradients in 8 x 8 cells</a></li>
                <li>
                    <a href="#1616-block-normalization" aria-label="16×16 Block Normalization">16×16 Block Normalization</a></li>
                <li>
                    <a href="#compute-hog-features-vector" aria-label="Compute HOG features vector">Compute HOG features vector</a></li></ul>
                </li>
                <li>
                    <a href="#visualizing-histogram-of-oriented-gradients" aria-label="Visualizing Histogram of Oriented Gradients">Visualizing Histogram of Oriented Gradients</a></li>
                <li>
                    <a href="#practice" aria-label="Practice">Practice</a></li>
                <li>
                    <a href="#application-in-hog" aria-label="Application in HOG">Application in HOG</a><ul>
                        
                <li>
                    <a href="#human-detection" aria-label="Human Detection">Human Detection</a></li>
                <li>
                    <a href="#import-lib" aria-label="Import lib">Import lib</a></li>
                <li>
                    <a href="#define-path-to-image" aria-label="Define path to image">Define path to image</a></li>
                <li>
                    <a href="#compute-the-hog-features-and-label-them" aria-label="Compute the HOG features and label them">Compute the HOG features and label them</a></li>
                <li>
                    <a href="#model-testing" aria-label="Model testing">Model testing</a></li>
                <li>
                    <a href="#load-model" aria-label="Load model">Load model</a></li>
                <li>
                    <a href="#sliding-window" aria-label="Sliding window">Sliding window</a></li>
                <li>
                    <a href="#detect-people-on-image" aria-label="Detect people on image">Detect people on image</a></li>
                <li>
                    <a href="#detect-people-on-video" aria-label="Detect people on video">Detect people on video</a></li></ul>
                </li>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#reference" aria-label="Reference">Reference</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><hr>
<p>There are many different methods in computer vision. When it comes to image classification, we can apply families of CNN models such as Inception Net, MobileNet, ResNet, DenseNet, AlexNet, U-Net, and so on. For object detection, models like YOLO, SSD, Faster R-CNN, Fast R-CNN, and Mask R-CNN are commonly used.
All the above algorithms belong to the deep learning category. However, before the deep learning boom, what algorithms were typically used in image processing? Today, we will explore a classic yet highly effective algorithm in image processing: <strong>HOG (Histogram of Oriented Gradients).</strong>
This algorithm generates <strong>features description</strong> for the purpose of <strong>object detection</strong>. From an image, two key matrices are extracted to store essential information: <strong>gradient magnitude</strong> and <strong>gradient orientation</strong>. By combining these two pieces of information into a histogram distribution—where the gradient magnitude is counted in bins according to gradient orientation—we obtain a <strong>HOG feature vector</strong> that represents the histogram. This is the basic concept, but in practice, the algorithm is more complex. The <strong>HOG vector</strong> is computed over <strong>local regions</strong>, similar to how CNNs operate, followed by <strong>local normalization</strong> to standardize measurements. Finally, the overall <strong>HOG vector</strong> is aggregated from all local vectors.</p>
<h2 id="hog-application">HOG Application<a hidden class="anchor" aria-hidden="true" href="#hog-application">#</a></h2>
<p>There are some applications using HOG and which have high accuracy.</p>
<ul>
<li>
<p><strong>Human detection</strong>: This application first represents in <a href="https://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf">Histogram of Orient Gradients for Human Detection</a>). HOG can detect one or more people walking on a street in an image.  <!-- raw HTML omitted -->
<!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
</li>
<li>
<p><strong>Face detection</strong>: HOG is a good algorithm on this problem. It has the ability to represent the main contours of the face based on the direction and gradient magnitude through vectors for each cell as shown bellow <!-- raw HTML omitted -->
<!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
</li>
<li>
<p><strong>Recognizing Various Objects:</strong> In addition, there are many cases of object recognition in static images, such as vehicles, traffic signals, animals, or even moving images extracted from videos.</p>
</li>
<li>
<p><strong>Creating Features for Image Classification Tasks:</strong> Many image classification tasks are built on small-sized datasets, where using deep learning networks may not always be effective and can lead to overfitting. The reason is that a small amount of data is often insufficient for training a model to accurately recognize object features. In such cases, using HOG (Histogram of Oriented Gradients) for feature extraction can yield better results. Specifically, I will also demonstrate an example at the end.</p>
</li>
</ul>
<h2 id="terminology">Terminology<a hidden class="anchor" aria-hidden="true" href="#terminology">#</a></h2>
<p>Before diving into the HOG algorithm, I will first explain the terms used:</p>
<ul>
<li>
<p><strong>Feature Descriptor:</strong> A feature descriptor is a representation of an image or an image patch that simplifies the image by extracting useful information and throwing away extraneous information.</p>
</li>
<li>
<p><strong>Histogram:</strong> A histogram is a graphical representation of the distribution of color intensities across different value ranges.</p>
</li>
<li>
<p><strong>Gradient:</strong> The derivative or vector of color intensity changes that helps detect movement directions of objects in an image.</p>
</li>
<li>
<p><strong>Local cell:</strong> A local cell is a small region in an image. In the HOG algorithm, an image is divided into multiple cells based on a square grid. Each cell is called a local cell.</p>
</li>
<li>
<p><strong>Local portion:</strong> A local region is a section of the image where feature extraction is performed. In the algorithm, this local region is referred to as a &ldquo;block.&rdquo;</p>
</li>
<li>
<p><strong>Local normalization:</strong> Normalization is performed within a local region. It is usually divided by either L2 norm or L1 norm. The purpose of normalization is to standardize color intensity values, making the distribution more consistent. This will be explained in more detail in the algorithm section.</p>
</li>
<li>
<p><strong>Gradient direction:</strong> The gradient direction represents the angle between the gradient vector components $x$ and $y$, which helps determine the direction of intensity change or, in other words, the direction of shading in the image. Given that $G_x$​ and $G_y$​ are the gradient values along the $x$ and $y$ axes of the image, the gradient direction is calculated as:</p>
<p>$$\theta = \arctan\left(\frac{G_y}{G_x}\right)$$</p>
</li>
<li>
<p><strong>Gradient magnitude:</strong> The magnitude of the gradient represents the length of the vector combining the gradients along the $x$ and $y$ directions. The histogram representation of this vector is used to describe the HOG features. The gradient magnitude is computed as:</p>
<p>$$∣G∣=\sqrt{G_x^2+G_y^2}$$​</p>
</li>
</ul>
<h2 id="definition">Definition<a hidden class="anchor" aria-hidden="true" href="#definition">#</a></h2>
<p>The key point in the working principle of HOG is that the local shape of an object can be described using two matrices: the <strong>gradient magnitude matrix</strong> and the <strong>gradient direction matrix</strong>.
First, the image is divided into a <strong>grid of square cells</strong>, where many adjacent or overlapping <strong>local regions</strong> are identified. These regions are similar to the <strong>local image regions</strong> used in convolutional operations in CNNs.
The main purpose of HOG feature extraction is to capture the local shape and edge information of an image. It works by computing the gradients (i.e., the changes in intensity) and then building histograms of these gradients over small, localized regions. This process allows the algorithm to effectively describe the appearance and structure of objects in an image, such as the contours and silhouettes of people.</p>
<ul>
<li>A <strong>local region</strong> consists of multiple <strong>local cells</strong> (in HOG, there are <strong>4 cells</strong>) with a size of <strong>8×8 pixels</strong></li>
<li>Then, a <strong>histogram of gradient magnitudes</strong> is computed for each <strong>local cell</strong>.</li>
<li>The <strong>HOG descriptor</strong> is formed by <strong>concatenating</strong> the four histogram vectors corresponding to each cell into a single combined vector.</li>
<li>To improve accuracy, each value in the <strong>histogram vector of a local region</strong> is <strong>normalized</strong> using either <strong>L2-norm</strong> or <strong>L1-norm</strong>.</li>
<li>This normalization aims to enhance <strong>invariance</strong> to <strong>lighting and shading changes</strong>.</li>
</ul>
<!-- raw HTML omitted -->
<p>The HOG descriptor has several key advantages over other feature descriptors:</p>
<ul>
<li>Since it operates on <strong>local cells</strong>, it is <strong>invariant</strong> to <strong>geometric transformations</strong> and <strong>brightness changes</strong>.</li>
<li>Furthermore, as <strong>Dalal and Triggs</strong> discovered, applying <strong>local region normalization</strong> allows the descriptor to ignore minor <strong>body movements</strong> in pedestrian detection, <strong>as long as the person maintains an upright posture</strong>.</li>
<li>This makes HOG particularly <strong>well-suited for human detection</strong> in images.</li>
</ul>
<h2 id="how-hog-works-step-by-step">How HOG Works (Step-by-step)<a hidden class="anchor" aria-hidden="true" href="#how-hog-works-step-by-step">#</a></h2>
<h3 id="preprocessing">Preprocessing<a hidden class="anchor" aria-hidden="true" href="#preprocessing">#</a></h3>
<p>In every image processing algorithm, the first step is preprocessing image. As mentioned earlier HOG feature descriptor used for pedestrian detection is calculated on a $64×128$ patch of an image. Of course, an image may be of any size. Typically, patches at multiple scales are analyzed at many image locations. The only constraint is that the patches being analyzed have a fixed aspect ratio. In our case, the patches need to have an aspect ratio of $1:2$. For example, they can be $100×200$, $128×256$, or $1000×2000$ but not $101×205$.</p>
<!-- raw HTML omitted -->
<p>We need to adjust the image to grayscale</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">cv2</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#Read the image</span>
</span></span><span class="line"><span class="cl"><span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s2">&#34;./img/bolt.jpg&#34;</span><span class="p">)</span> <span class="c1"># Load BGR format</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Image not loaded. Check the file path and file integrity.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Convert BGR to RGB for proper color display in matplotlib</span>
</span></span><span class="line"><span class="cl">    <span class="n">img_rgb</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">#Convert to grayscale</span>
</span></span><span class="line"><span class="cl">    <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">img_rgb</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">gray</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">#Show the images</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_rgb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&#34;Original&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gray</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&#34;Gray Image&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span></span></code></pre></div><p><img loading="lazy" src="/posts/hog/img/output1.png"></p>
<h3 id="compute-the-gradient">Compute the gradient<a hidden class="anchor" aria-hidden="true" href="#compute-the-gradient">#</a></h3>
<p>To calculate a HOG descriptor, we need to first calculate the horizontal and vertical gradients, the common way to compute is using the <strong>Sobel operator</strong></p>
<ul>
<li>Horizontal gradient
$$G_x =
\begin{pmatrix}
-1 &amp; 0 &amp; 2 \
-2 &amp; 0 &amp; 2 \
-1 &amp; 0 &amp; 1
\end{pmatrix}*\textbf{I}
$$</li>
<li>Vertical gradient
$$G_y = \begin{bmatrix}
-1 &amp; -2 &amp; -1 \
0 &amp; 0 &amp; 0 \
1 &amp; 2 &amp; 1
\end{bmatrix} * \mathbf{I}
$$
Where $*$ be a convolution between a filter and an image</li>
<li>Gradient magnitude
$$ G=\sqrt{G_x^2+G_y^2}$$</li>
<li>Gradient direction
$$\theta=\arctan\Bigl(\frac{G_y}{G_x}\Bigl)$$</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="c1">#Calculate gradient gx,gy</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">gx</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Sobel</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CV_32F</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ksize</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">gy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Sobel</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CV_32F</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ksize</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gray shape: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gray</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gx shape: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gx</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gy shape: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gy</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Compute magnitude and direction gradient</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">g</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cartToPolar</span><span class="p">(</span><span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">,</span> <span class="n">angleInDegrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gradient format: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;theta format: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</span></span></code></pre></div><p>The output</p>
<pre tabindex="0"><code>gray shape: (480, 640)
gx shape: (480, 640)
gy shape: (480, 640)
gradient format: (480, 640)
theta format: (480, 640)
</code></pre><p>Visualize the plot</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;gradient of x&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;gradient of y&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Magnitute of gradient&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Direction of gradient&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span></span></code></pre></div><p><img loading="lazy" src="/posts/hog/img/output2.png"></p>
<h3 id="calculate-histogram-of-gradients-in-8-x-8-cells">Calculate Histogram of Gradients in 8 x 8 cells<a hidden class="anchor" aria-hidden="true" href="#calculate-histogram-of-gradients-in-8-x-8-cells">#</a></h3>
<p>In this step, the image is divided into $8\times8$ cells and a histogram of gradients is calculated for each $8\times8$. One of the important reasons to use a feature description to describe a patch of an image is that it provided a compact representation. An $8\times8$ patch contain $8\times8\times3=192$ pixels. The gradient of this patch contains $2$ values (magnitude and direction) per pixel which adds up to $8\times8\times2 = 128$ numbers include $64$ values of gradient magnitude and $64$ values of gradient direction.
By the end of this section we will see how these $128$ numbers are represented using a <strong>9-bin histogram</strong> which can be stored as an array of $9$ numbers. Not only is the representation more compact, calculating a histogram over a patch makes this representation more robust to noise. Individual gradients may have noise, but a histogram over $8\times8$ patch makes the representation much less sensitive to noise.</p>
<p>But why $8\times8$ patch ? Why not $32\times32$ ? It is a design choice informed by the scale of features we are looking for. HOG was used for pedestrian detection initially. $8\times8$ cells in a photo of a pedestrian scaled to $64\times128$ are big enough to capture interesting features ( e.g. the face, the top of the head etc.).
<img loading="lazy" src="/posts/hog/img/pic5.png">
On the right, we see the raw numbers representing the gradients in the 8×8 cells with one minor difference — the angles are between $0$ and $180$ degrees instead of $0$ to $360$ degrees. These are called <strong>“unsigned” gradients</strong> because a gradient and it’s negative are represented by the same numbers. In other words, a gradient arrow and the one $180$ degrees opposite to it are considered the same. But, why not use the $0$ – $360$ degrees ?</p>
<p>Empirically it has been shown that unsigned gradients work better than signed gradients for pedestrian detection. Some implementations of HOG will allow you to specify if you want to use signed gradients.</p>
<p>The next step is to create a histogram of gradients in these $8\times8$ cells. The histogram contains 9 bins corresponding to angles $0, 20, 40 … 160$. The following figure illustrates the process. We are looking at magnitude and direction of the gradient of the same $8\times8$ patch as in the previous figure.
A bin is selected based on the direction, and the vote (the value that goes into the bin) is selected based on the magnitude. Let’s first focus on the pixel encircled in blue. It has an angle (direction) of $80$ degrees and magnitude of $2$. So it adds $2$ to the $5^{th}$ bin. The gradient at the pixel encircled using red has an angle of $10$ degrees and magnitude of $4$. Since $10$ degrees is half way between $0$ and $20$, the vote by the pixel splits evenly into the two bins.</p>
<!-- raw HTML omitted -->
<p>The approach when gradient direction doesn&rsquo;t fall in any bin(like an example 10 degrees), we will use linear interpolation to divided the gradients to 2 continuous bins which gradient direction falls. Obviously, the gradient direction equal $x$ map to the gradient magnitude $y$, where $x \in [x_0,x_1]$. It&rsquo;s will fall to a point between $(l-1)$ bin and $l$ bin. So that we write
$$ x_{l-1}=\frac{x_1-x}{x_1-x_0}*y,  x_{l}=\frac{x-x_0}{x_1-x_0}*y  $$</p>
<!-- raw HTML omitted -->
<p>Take a sum of each gradient magnitude belong in one bins from vector bins and we collect <strong>Histogram of Gradient</strong></p>
<!-- raw HTML omitted -->
<h3 id="1616-block-normalization">16×16 Block Normalization<a hidden class="anchor" aria-hidden="true" href="#1616-block-normalization">#</a></h3>
<p>In the previous step, we created a histogram based on the gradient of the image. Gradients of an image are sensitive to overall lighting. If you make the image darker by dividing all pixel values by 2, the gradient magnitude will change by half, and therefore the histogram values will change by half.</p>
<p>Ideally, we want our descriptor to be independent of lighting variations. In other words, we would like to “normalize” the histogram so they are not affected by lighting variations.</p>
<p>Let&rsquo;s say we have an RGB color vector $[128, 64, 32]$. This length of this vector is $\sqrt{128^2+64^2+32^2}\approx 146.64$. This is call L2 norm. Dividing each element of this vector give us a normalized vector $[0.87,0.43,0.22]$</p>
<p>Now consider another vector in which the elements are twice the value of the first vector $2 \times [ 128, 64, 32 ] = [ 256, 128, 64 ]$. You can work it out yourself to see that normalizing $[ 256, 128, 64 ]$ will result in $[0.87, 0.43, 0.22]$, which is the same as the normalized version of the original RGB vector. You can see that normalizing a vector removes the scale.</p>
<!-- raw HTML omitted -->
<p>The normalization will be processed in a block size $2\times 2$ cell (each cell size $8\times8$ pixel). So we will have 4 vector histogram size $1\times9$, concatenate vectors and we will have one vector histogram size $1\times36$ and then normalized in this vector. Sliding the window will process the same as convolution in CNN with step_size = 8 pixels.</p>
<h3 id="compute-hog-features-vector">Compute HOG features vector<a hidden class="anchor" aria-hidden="true" href="#compute-hog-features-vector">#</a></h3>
<p>After normalizing the histogram vectors, we then concatenate these $1×36$ vectors into a single large vector. This becomes the HOG vector representing the entire image.</p>
<p>For example, suppose our image is divided into a grid of squares of size $16×8$ (each cell is $8×8$). The HOG computation moves $7$ steps horizontally and $15$ steps vertically. Thus, there are a total of $7×15 = 105$ patches, each corresponding to one $36$-dimensional histogram vector. Consequently, the final HOG vector will have $105×36 = 3780$ dimensions. This is a relatively large vector, which allows it to capture the image’s features quite effectively.</p>
<h2 id="visualizing-histogram-of-oriented-gradients">Visualizing Histogram of Oriented Gradients<a hidden class="anchor" aria-hidden="true" href="#visualizing-histogram-of-oriented-gradients">#</a></h2>
<p>The HOG descriptor of an image patch is usually visualized by plotting the 9×1 normalized histograms in the 8×8 cells. See image on the side. You will notice that dominant direction of the histogram captures the shape of the person, especially around the torso and legs.</p>
<!-- raw HTML omitted -->
<h2 id="practice">Practice<a hidden class="anchor" aria-hidden="true" href="#practice">#</a></h2>
<p>We will use opencv to calculate the HOG features</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Original </span><span class="si">{}</span><span class="s2">&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cell_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># h x w pixels</span>
</span></span><span class="line"><span class="cl"><span class="n">block_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># h x w cells</span>
</span></span><span class="line"><span class="cl"><span class="n">nbins</span> <span class="o">=</span> <span class="mi">9</span> <span class="c1"># number of bins in Histogram</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># winSize = the size of the image region (or window) that will be used by the HOG (Histogram of Oriented Gradients) descriptor</span>
</span></span><span class="line"><span class="cl"><span class="n">winSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span> <span class="n">cell_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cell_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">cell_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">cell_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1"># blockSize = the size compute in pixels</span>
</span></span><span class="line"><span class="cl"><span class="n">blockSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cell_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">block_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">cell_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1"># blockStride = how far (in pixels) the detection window moves from one block to the next.</span>
</span></span><span class="line"><span class="cl"><span class="n">blockStride</span> <span class="o">=</span> <span class="n">cell_size</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;winSize&#34;</span><span class="p">,</span><span class="n">winSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;blockSize&#34;</span><span class="p">,</span><span class="n">block_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;blockStride&#34;</span><span class="p">,</span><span class="n">blockStride</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">hog</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">HOGDescriptor</span><span class="p">(</span><span class="n">_winSize</span><span class="o">=</span><span class="n">winSize</span><span class="p">,</span><span class="n">_blockSize</span><span class="o">=</span><span class="n">blockSize</span><span class="p">,</span><span class="n">_blockStride</span><span class="o">=</span><span class="n">blockStride</span><span class="p">,</span><span class="n">_cellSize</span><span class="o">=</span><span class="n">cell_size</span><span class="p">,</span><span class="n">_nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># size of cell grid (from pixel -&gt; cell)</span>
</span></span><span class="line"><span class="cl"><span class="n">n_cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">winSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="n">cell_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">winSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="n">cell_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;n_cell&#34;</span><span class="p">,</span><span class="n">n_cell</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">hog_feature</span> <span class="o">=</span> <span class="n">hog</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">block_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">n_cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">block_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                                       <span class="p">,</span><span class="n">block_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">block_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nbins</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="p">,</span> <span class="mi">3</span> <span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;hog feature&#34;</span><span class="p">,</span> <span class="n">hog_feature</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span></span></code></pre></div><p>and the results</p>
<pre tabindex="0"><code>Original (395, 634, 3)
winSize (632, 392)
blockSize (2, 2)
blockStride (8, 8)
n_cell (79, 49)
hog feature (48, 78, 2, 2, 9)
</code></pre><p><strong>Note:</strong> Don&rsquo;t like the order of the .shape, opencv use the order width x height (instead height x width).<br>
We can visualize HOG distribution</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">exposure</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">feature</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">cv2</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">hogImage</span><span class="p">)</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">hog</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">orientations</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">pixels_per_cell</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">cells_per_block</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">transform_sqrt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block_norm</span><span class="o">=</span><span class="s2">&#34;L2&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">visualize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">hogImage</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">hogImage</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">hogImage</span> <span class="o">=</span> <span class="n">hogImage</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&#34;uint8&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">hogImage</span><span class="p">)</span>
</span></span></code></pre></div><!-- raw HTML omitted -->
<h2 id="application-in-hog">Application in HOG<a hidden class="anchor" aria-hidden="true" href="#application-in-hog">#</a></h2>
<h3 id="human-detection">Human Detection<a hidden class="anchor" aria-hidden="true" href="#human-detection">#</a></h3>
<p>To detect human in image or also video, we can use a pre-trained SVM (Support Vector Machine) model that makes predictions based on features extracted by the HOG (Histogram of Oriented Gradients) algorithm.</p>
<h3 id="import-lib">Import lib<a hidden class="anchor" aria-hidden="true" href="#import-lib">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">hog</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">pyramid_gaussian</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">skimage.io</span> <span class="kn">import</span> <span class="n">imread</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">joblib</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">LabelEncoder</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">LinearSVC</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span><span class="p">,</span> <span class="n">accuracy_score</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">imutils.object_detection</span> <span class="kn">import</span> <span class="n">non_max_suppression</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">imutils</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">cv2</span> 
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">argparse</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">cv2</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">glob</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span> <span class="c1"># This will be used to read/modify images (can be done via OpenCV too)</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
</span></span></code></pre></div><h3 id="define-path-to-image">Define path to image<a hidden class="anchor" aria-hidden="true" href="#define-path-to-image">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="n">base_path_test</span> <span class="o">=</span> <span class="s2">&#34;../data/human-and-non-human/test_set/test_set&#34;</span> <span class="c1"># path for test</span>
</span></span><span class="line"><span class="cl"><span class="n">base_path_train</span> <span class="o">=</span> <span class="s2">&#34;../data/dataset&#34;</span> <span class="c1"># path for train</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># join the path</span>
</span></span><span class="line"><span class="cl"><span class="n">pos_im_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_path_train</span><span class="p">,</span> <span class="s2">&#34;positive&#34;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="n">neg_im_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_path_train</span><span class="p">,</span> <span class="s2">&#34;negative&#34;</span><span class="p">)</span> <span class="c1">#define negative image for SVM training</span>
</span></span><span class="line"><span class="cl"><span class="n">pos_im_path_test</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_path_test</span><span class="p">,</span> <span class="s2">&#34;humans&#34;</span><span class="p">)</span> <span class="c1"># for test data</span>
</span></span><span class="line"><span class="cl"><span class="n">neg_im_path_test</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_path_test</span><span class="p">,</span> <span class="s2">&#34;non-humans&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Check if there not exist path</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pos_im_path</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Error: Path does not exist - </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">pos_im_path</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">neg_im_path</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Error: Path does not exist - </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">neg_im_path</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pos_im_path_test</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Error: Path does not exist - </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">pos_im_path_test</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">neg_im_path_test</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Error: Path does not exist - </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">neg_im_path_test</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Take the image in that path</span>
</span></span><span class="line"><span class="cl"><span class="n">pos_im_listing</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">pos_im_path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">neg_im_listing</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">neg_im_path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pos_im_listing_test</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">pos_im_path_test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">neg_im_listing_test</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">neg_im_path_test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">num_pos_samples</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">pos_im_listing</span><span class="p">)</span> <span class="c1"># simply states the total no. of images</span>
</span></span><span class="line"><span class="cl"><span class="n">num_neg_samples</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">neg_im_listing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">num_pos_test</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">pos_im_listing_test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">num_neg_test</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">neg_im_listing_test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">num_pos_samples</span><span class="p">)</span> <span class="c1"># prints the number value of the no.of samples in positive dataset</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">num_neg_samples</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">num_pos_test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">num_neg_test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
</span></span></code></pre></div><h3 id="compute-the-hog-features-and-label-them">Compute the HOG features and label them<a hidden class="anchor" aria-hidden="true" href="#compute-the-hog-features-and-label-them">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="c1"># Putting label into positive image</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">winSize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">blockSize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">blockStride</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">cellSize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nbins</span> <span class="o">=</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">hog</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">HOGDescriptor</span><span class="p">(</span><span class="n">winSize</span><span class="p">,</span> <span class="n">blockSize</span><span class="p">,</span> <span class="n">blockStride</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">pos_im_listing</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">img_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pos_im_path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&#34;RGB&#34;</span><span class="p">)</span> <span class="c1"># Open the file</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert into NumPy array</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert RGB to BGR (for OpenCV compatibility) </span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2BGR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Resize to standard HOG size (64x128) to ensure consistency</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">#Convert to grayscale</span>
</span></span><span class="line"><span class="cl">        <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">fd</span> <span class="o">=</span> <span class="n">hog</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">gray</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="c1"># Must change into 1D array (because fd return a multi-dimensional vector)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3780</span><span class="p">:</span>  <span class="c1"># Expected size for 64x128 image</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> due to incorrect HOG feature shape: </span><span class="si">{</span><span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>  <span class="c1"># Skip this sample</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Processed training data (positive): </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> (Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Putting label into negative image</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">neg_im_listing</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">img_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">neg_im_path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&#34;RGB&#34;</span><span class="p">)</span> <span class="c1"># Open the file</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert into NumPy array</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert RGB to BGR (for OpenCV compatibility) </span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2BGR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Resize to standard HOG size (64x128) to ensure consistency</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">#Convert to grayscale</span>
</span></span><span class="line"><span class="cl">        <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">fd</span> <span class="o">=</span> <span class="n">hog</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">gray</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="c1"># Must change into 1D array (because fd return a multi-dimensional vector)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3780</span><span class="p">:</span>  <span class="c1"># Expected size for 64x128 image</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> due to incorrect HOG feature shape: </span><span class="si">{</span><span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>  <span class="c1"># Skip this sample</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Processed training data (negative): </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> (Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## Testing label</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">data_test</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="n">label_test</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">pos_im_listing_test</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">img_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pos_im_path_test</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&#34;RGB&#34;</span><span class="p">)</span> <span class="c1"># Open the file</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert into NumPy array</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert RGB to BGR (for OpenCV compatibility) </span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2BGR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Resize to standard HOG size (64x128) to ensure consistency</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">#Convert to grayscale</span>
</span></span><span class="line"><span class="cl">        <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Create a base features (if don&#39;t add any parameter, opencv will understand to take a base parameter)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">fd</span> <span class="o">=</span> <span class="n">hog</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">gray</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="c1"># Must change into 1D array (because fd return a multi-dimensional vector)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3780</span><span class="p">:</span>  <span class="c1"># Expected size for 64x128 image</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> due to incorrect HOG feature shape: </span><span class="si">{</span><span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>  <span class="c1"># Skip this sample</span>
</span></span><span class="line"><span class="cl">        <span class="n">data_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">label_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Processed test data (positive): </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> (Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Putting label into negative image</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">neg_im_listing_test</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">img_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">neg_im_path_test</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&#34;RGB&#34;</span><span class="p">)</span> <span class="c1"># Open the file</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert into NumPy array</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert RGB to BGR (for OpenCV compatibility) </span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2BGR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Resize to standard HOG size (64x128) to ensure consistency</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">#Convert to grayscale</span>
</span></span><span class="line"><span class="cl">        <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">fd</span> <span class="o">=</span> <span class="n">hog</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">gray</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="c1"># Must change into 1D array (because fd return a multi-dimensional vector)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3780</span><span class="p">:</span>  <span class="c1"># Expected size for 64x128 image</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> due to incorrect HOG feature shape: </span><span class="si">{</span><span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>  <span class="c1"># Skip this sample</span>
</span></span><span class="line"><span class="cl">        <span class="n">data_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">label_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Processed test data (negative): </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> (Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="model-testing">Model testing<a hidden class="anchor" aria-hidden="true" href="#model-testing">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34; Constructing training/testing split...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">data_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_test</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">label_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">label_test</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">data_test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">label_test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">trainData</span><span class="p">,</span> <span class="n">testData</span><span class="p">,</span> <span class="n">trainLabels</span><span class="p">,</span> <span class="n">testLabels</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_test</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">label_test</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Train the linear SVM</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34; Training Linear SVM classifier...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">LinearSVC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">trainData</span><span class="p">,</span> <span class="n">trainLabels</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Evaluate the classifier</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34; Evaluating classifier on test data ...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">testData</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Calculate accuracy</span>
</span></span><span class="line"><span class="cl"><span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">testLabels</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Accuracy: </span><span class="si">{</span><span class="n">accuracy</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Report</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span><span class="n">classification_report</span><span class="p">(</span><span class="n">testLabels</span><span class="p">,</span> <span class="n">pred</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Save the model</span>
</span></span><span class="line"><span class="cl"><span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;SVM_HOG.pkl&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;SVM Model save Successfully!&#34;</span><span class="p">)</span>
</span></span></code></pre></div><pre tabindex="0"><code>Constructing training/testing split...
(1554, 3780)
(1554,)
 Training Linear SVM classifier...
 Evaluating classifier on test data ...
Accuracy: 0.8294723294723295
Report
               precision    recall  f1-score   support

           0       0.84      0.98      0.91      1309
           1       0.00      0.00      0.00       245

    accuracy                           0.83      1554
   macro avg       0.42      0.49      0.45      1554
weighted avg       0.71      0.83      0.76      1554

SVM Model save Successfully!
</code></pre><h3 id="load-model">Load model<a hidden class="anchor" aria-hidden="true" href="#load-model">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="c1"># Load the model by joblib</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&#34;SVM_HOG.pkl&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;SVM Model load Successfully!&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="sliding-window">Sliding window<a hidden class="anchor" aria-hidden="true" href="#sliding-window">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="c1"># Sliding window technique</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sliding_window</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">stepSize</span><span class="p">,</span> <span class="n">windowSize</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">windowSize</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stepSize</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">windowSize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stepSize</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">yield</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="p">:</span><span class="n">y</span> <span class="o">+</span> <span class="n">windowSize</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span> <span class="o">+</span> <span class="n">windowSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
</span></span></code></pre></div><h3 id="detect-people-on-image">Detect people on image<a hidden class="anchor" aria-hidden="true" href="#detect-people-on-image">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="n">down_scale</span><span class="o">=</span><span class="mf">1.25</span>
</span></span><span class="line"><span class="cl"><span class="n">window_size</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">128</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">output_folder</span> <span class="o">=</span> <span class="s1">&#39;results/&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Detect</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">pos_im_listing_test</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">scale</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">img_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pos_im_path_test</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&#34;RGB&#34;</span><span class="p">)</span> <span class="c1"># Open the file</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span><span class="mi">200</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Debug: Check the shape of the image</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Skip&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">detections</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Using pyramid to detect the larger or smaller object (scaled the image purpose sliding window will detect different object with original cell)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">resized</span> <span class="ow">in</span> <span class="n">pyramid_gaussian</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">downscale</span><span class="o">=</span><span class="n">down_scale</span><span class="p">,</span> <span class="n">channel_axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># pyramid_gaussian convert the image into [0, 1]</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># So we need to convert back to unit8 </span>
</span></span><span class="line"><span class="cl">            <span class="n">resized</span> <span class="o">=</span> <span class="p">(</span><span class="n">resized</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># Convert float64 to uint8, go back [0, 255]</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">y</span> <span class="p">,</span> <span class="n">window</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sliding_window</span><span class="p">(</span><span class="n">resized</span><span class="p">,</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">windowSize</span> <span class="o">=</span> <span class="n">window_size</span><span class="p">):</span> <span class="c1"># You can adjust the stepsize</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># validation the window size</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                    
</span></span><span class="line"><span class="cl">                <span class="c1"># change the window to gray, easily compute HOG                    </span>
</span></span><span class="line"><span class="cl">                <span class="n">window</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2GRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">#Extract HOG features</span>
</span></span><span class="line"><span class="cl">                <span class="n">fds</span> <span class="o">=</span> <span class="n">hog</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">fds</span> <span class="o">=</span> <span class="n">fds</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span> <span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Make become 2d</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">#prediction SVM</span>
</span></span><span class="line"><span class="cl">                <span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># print(pred)</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">pred</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">):</span> <span class="c1"># add threshold</span>
</span></span><span class="line"><span class="cl">                        <span class="n">back_to_original</span> <span class="o">=</span> <span class="n">down_scale</span> <span class="o">**</span> <span class="n">scale</span> <span class="c1"># When we use pyramid to shrink the image, we will give the detection window back to original size</span>
</span></span><span class="line"><span class="cl">                        <span class="n">detections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">back_to_original</span> <span class="p">,</span> <span class="n">y</span><span class="o">*</span><span class="n">back_to_original</span>
</span></span><span class="line"><span class="cl">                                           <span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">back_to_original</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">back_to_original</span><span class="p">),</span><span class="n">model</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">fds</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">            <span class="n">scale</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># increase the scale </span>
</span></span><span class="line"><span class="cl">        <span class="n">clone</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">rects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span> <span class="o">+</span> <span class="n">w</span> <span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">h</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="n">sc</span> <span class="o">=</span> <span class="p">[</span><span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">score</span><span class="p">)</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Apply Non-Maximum Suppression (NMS) if detections exist</span>
</span></span><span class="line"><span class="cl">        <span class="n">final_detections</span> <span class="o">=</span> <span class="n">non_max_suppression</span><span class="p">(</span><span class="n">rects</span><span class="p">,</span> <span class="n">probs</span><span class="o">=</span><span class="n">sc</span><span class="p">,</span> <span class="n">overlapThresh</span><span class="o">=</span><span class="mf">0.35</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">#Draw bouding boxes</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">y</span> <span class="p">,</span> <span class="n">w</span> <span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">in</span> <span class="n">final_detections</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">h</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert BGR to RGB for display in matplotlib</span>
</span></span><span class="line"><span class="cl">        <span class="n">img_rgb</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># write down the result</span>
</span></span><span class="line"><span class="cl">        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_folder</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">img_rgb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Processed </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> successful&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Skipping </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> (Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span></code></pre></div><p>Before using NMS</p>
<!-- raw HTML omitted -->
<p>After using NMS</p>
<!-- raw HTML omitted -->
<h3 id="detect-people-on-video">Detect people on video<a hidden class="anchor" aria-hidden="true" href="#detect-people-on-video">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span><span class="p">,</span> <span class="n">clear_output</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">yt_dlp</span>  
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">PIL.Image</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Load YouTube video using pafy</span>
</span></span><span class="line"><span class="cl"><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://youtu.be/NyLF8nHIquM&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Get the best video stream</span>
</span></span><span class="line"><span class="cl"><span class="n">ydl_opts</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">with</span> <span class="n">yt_dlp</span><span class="o">.</span><span class="n">YoutubeDL</span><span class="p">(</span><span class="n">ydl_opts</span><span class="p">)</span> <span class="k">as</span> <span class="n">ydl</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">info_dict</span> <span class="o">=</span> <span class="n">ydl</span><span class="o">.</span><span class="n">extract_info</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_url</span> <span class="o">=</span> <span class="n">info_dict</span><span class="p">[</span><span class="s1">&#39;url&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cap</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="n">video_url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Set Optimized Performance</span>
</span></span><span class="line"><span class="cl"><span class="n">cv2</span><span class="o">.</span><span class="n">setUseOptimized</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">cv2</span><span class="o">.</span><span class="n">setNumThreads</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># Adjust based on CPU</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Process every nth frame (skip frames)</span>
</span></span><span class="line"><span class="cl"><span class="n">frame_skip</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">frame_count</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Read and process frames</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">cap</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">frame_count</span> <span class="o">%</span> <span class="n">frame_skip</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame_count</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">continue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">frame_count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment counter</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span><span class="mi">512</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">detections</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">scale</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Using pyramid to detect the larger or smaller object (scaled the image purpose sliding window will detect different object with original cell)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">resized</span> <span class="ow">in</span> <span class="n">pyramid_gaussian</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">downscale</span><span class="o">=</span><span class="n">down_scale</span><span class="p">,</span> <span class="n">channel_axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># pyramid_gaussian convert the image into [0, 1]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># So we need to convert back to unit8 </span>
</span></span><span class="line"><span class="cl">        <span class="n">resized</span> <span class="o">=</span> <span class="p">(</span><span class="n">resized</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># Convert float64 to uint8, go back [0, 255]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">y</span> <span class="p">,</span> <span class="n">window</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sliding_window</span><span class="p">(</span><span class="n">resized</span><span class="p">,</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">windowSize</span> <span class="o">=</span> <span class="n">window_size</span><span class="p">):</span> <span class="c1"># You can adjust the stepsize</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># validation the window size</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">            <span class="c1"># change the window to gray, easily compute HOG                    </span>
</span></span><span class="line"><span class="cl">            <span class="n">window</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2GRAY</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#Extract HOG features</span>
</span></span><span class="line"><span class="cl">            <span class="n">fds</span> <span class="o">=</span> <span class="n">hog</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">fds</span> <span class="o">=</span> <span class="n">fds</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span> <span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Make become 2d</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">#prediction SVM</span>
</span></span><span class="line"><span class="cl">            <span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># print(pred)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">pred</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">):</span> <span class="c1"># add threshold</span>
</span></span><span class="line"><span class="cl">                    <span class="n">back_to_original</span> <span class="o">=</span> <span class="n">down_scale</span> <span class="o">**</span> <span class="n">scale</span> <span class="c1"># When we use pyramid to shrink the image, we will give the detection window back to original size</span>
</span></span><span class="line"><span class="cl">                    <span class="n">detections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">back_to_original</span> <span class="p">,</span> <span class="n">y</span><span class="o">*</span><span class="n">back_to_original</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">back_to_original</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">back_to_original</span><span class="p">),</span><span class="n">model</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">fds</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="n">scale</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># increase the scale </span>
</span></span><span class="line"><span class="cl">    <span class="n">clone</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">rects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span> <span class="o">+</span> <span class="n">w</span> <span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">h</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">sc</span> <span class="o">=</span> <span class="p">[</span><span class="n">score</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">score</span><span class="p">)</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Apply Non-Maximum Suppression (NMS) if detections exist</span>
</span></span><span class="line"><span class="cl">    <span class="n">final_detections</span> <span class="o">=</span> <span class="n">non_max_suppression</span><span class="p">(</span><span class="n">rects</span><span class="p">,</span> <span class="n">probs</span><span class="o">=</span><span class="n">sc</span><span class="p">,</span> <span class="n">overlapThresh</span><span class="o">=</span><span class="mf">0.35</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">#Draw bouding boxes</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">y</span> <span class="p">,</span> <span class="n">w</span> <span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">in</span> <span class="n">final_detections</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">h</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="s1">&#39;Person: </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sc</span><span class="p">)),</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Convert BGR to RGB for display in matplotlib</span>
</span></span><span class="line"><span class="cl">    <span class="n">img_rgb</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">img_pil</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">img_rgb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Clear previous frame and display new frame</span>
</span></span><span class="line"><span class="cl">    <span class="n">clear_output</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">display</span><span class="p">(</span><span class="n">img_pil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Add a small delay and allow stopping</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">27</span><span class="p">:</span>  <span class="c1"># Press ESC to exit</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl"><span class="n">cap</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
</span></span></code></pre></div><!-- raw HTML omitted -->
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>In image processing, the Histogram of Oriented Gradients (HOG) algorithm is one of the powerful feature descriptors that encodes an image into a feature vector with a sufficiently large number of dimensions to effectively classify images. The algorithm works based on representing a histogram vector of gradient magnitudes according to bins of gradient directions applied to local image regions. Normalization methods are applied to make the aggregated histogram vector invariant to changes in image intensity, ensuring consistency for images with the same content but different brightness levels.</p>
<p>In object detection, the HOG algorithm proves to be highly effective, particularly in detecting people at various scales. Additionally, in some image classification cases where the dataset is small, large neural networks such as CNNs may not perform accurately due to the training set not covering all possible variations. In such situations, applying classical feature extraction methods like HOG can yield surprisingly good results while requiring fewer computational resources and lower costs.</p>
<p>This demonstrates that although HOG is an older method, it remains highly effective in many applications. Depending on the specific scenario, we may choose to use the HOG algorithm instead of necessarily applying a deep learning model with millions of parameters to achieve high accuracy.</p>
<h2 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h2>
<ol>
<li><a href="https://phamdinhkhanh.github.io/2019/11/22/HOG.html">https://phamdinhkhanh.github.io/2019/11/22/HOG.html</a></li>
<li><a href="https://lilianweng.github.io/posts/2017-10-29-object-recognition-part-1/">Object Detection for Dummies Part 1: Gradient Vector, HOG, and SS | Lil&rsquo;Log</a></li>
<li><a href="https://learnopencv.com/histogram-of-oriented-gradients/">Histogram of Oriented Gradients explained using OpenCV</a></li>
<li><a href="https://github.com/nguyentuss/CV">https://github.com/nguyentuss/CV</a> (full code and data put in here)</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%23cv/">#CV</a></li>
      <li><a href="http://localhost:1313/tags/%23machine_learning/">#Machine_Learning</a></li>
      <li><a href="http://localhost:1313/tags/%23extract_image/">#Extract_image</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/cnn/">
    <span class="title">« Prev</span>
    <br>
    <span>Convolution Neural Network</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/introduction/">
    <span class="title">Next »</span>
    <br>
    <span>Introduction</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
